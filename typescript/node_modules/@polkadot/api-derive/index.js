"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  derive: true
};
exports.default = decorateDerive;
exports.derive = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var accounts = _interopRequireWildcard(require("./accounts"));

var balances = _interopRequireWildcard(require("./balances"));

var chain = _interopRequireWildcard(require("./chain"));

var contracts = _interopRequireWildcard(require("./contracts"));

var democracy = _interopRequireWildcard(require("./democracy"));

var elections = _interopRequireWildcard(require("./elections"));

var imOnline = _interopRequireWildcard(require("./imOnline"));

var session = _interopRequireWildcard(require("./session"));

var staking = _interopRequireWildcard(require("./staking"));

var _type = require("./type");

Object.keys(_type).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _type[key];
    }
  });
});

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Returns an object that will inject `api` into all the functions inside
 * `allSections`, and keep the object architecture of `allSections`.
 */
function injectFunctions(api, allSections) {
  return Object.keys(allSections).reduce((deriveAcc, sectionName) => {
    const section = allSections[sectionName];
    deriveAcc[sectionName] = Object.keys(section).reduce((sectionAcc, _methodName) => {
      const methodName = _methodName; // Not sure what to do here, casting as any. Though the final types are good

      const method = section[methodName](api); // idem

      sectionAcc[methodName] = method;
      return sectionAcc;
    }, {});
    return deriveAcc;
  }, {});
}

const derive = {
  accounts,
  balances,
  chain,
  contracts,
  democracy,
  elections,
  imOnline,
  session,
  staking
};
exports.derive = derive;

// FIXME The return type of this function should be {...ExactDerive, ...DeriveCustom}
// For now we just drop the custom derive typings
function decorateDerive(api) {
  let custom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _objectSpread({}, injectFunctions(api, derive), {}, injectFunctions(api, custom));
}