"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _api = require("@polkadot/api");

var _testingPairs = _interopRequireDefault(require("@polkadot/keyring/testingPairs"));

var _codec = require("@polkadot/types/codec");

// Copyright 2017-2019 @polkadot/api authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
// Simple non-runnable checks to test type definitions in the editor itself
function consts(api) {
  // constants has actual value & metadata
  console.log(api.consts.balances.creationFee.toHex(), api.consts.balances.creationFee.meta.documentation.map(s => s.toString()).join(''));
}

async function derive(api) {
  await api.derive.chain.subscribeNewHeads(header => {
    console.log('current author:', header.author);
  });
  const fees = await api.derive.balances.fees();
  console.log('fees', fees);
}

async function query(api, keyring) {
  const intentions = await api.query.staking.intentions();
  console.log('intentions:', intentions); // api.query.*.* is well-typed

  const bar = await api.query.foo.bar(); // bar is Codec (unknown module)

  const bal = await api.query.balances.freeBalance(keyring.alice.address); // bal is Balance

  const bal2 = await api.query.balances.freeBalance(keyring.alice.address, 'WRONG_ARG'); // bal2 is Codec (wrong args)

  const override = await api.query.balances.freeBalance(keyring.alice.address); // override is still available

  const oldBal = await api.query.balances.freeBalance.at('abcd', keyring.alice.address); // It's hard to correctly type .multi. Expected: `Balance[]`, actual: Codec[].
  // In the meantime, we can case with `<Balance>`

  const multi = await api.query.balances.freeBalance.multi([keyring.alice.address, keyring.bob.address]);
  console.log('query types:', bar, bal, bal2, override, oldBal, multi); // check multi for unsub

  const multiUnsub = await api.queryMulti([[api.query.system.accountNonce, keyring.eve.address], [api.query.system.accountNonce, keyring.bob.address]], balances => {
    console.log('balances', balances);
    multiUnsub();
  });
}

async function rpc(api) {
  await api.rpc.chain.subscribeNewHeads(header => {
    console.log('current header:', header);
  });
  await api.rpc.state.subscribeStorage(['my_balance_key'], (_ref) => {
    let [balance] = _ref;
    console.log('current balance:', balance.toString());
  });
}

function types() {
  // check correct types with `createType`
  const balance = (0, _codec.createType)('Balance', 2);
  const gas = (0, _codec.createType)('Gas', 2);
  const compact = (0, _codec.createType)('Compact<u32>', 2); // const random = createType('RandomType', 2); // This one should deliberately show a TS error

  const gasUnsafe = (0, _codec.createTypeUnsafe)('Gas', [2]);
  const overriddenUnsafe = (0, _codec.createTypeUnsafe)('Gas', [2]);
  console.log(balance, gas, compact, gasUnsafe, overriddenUnsafe);
}

async function tx(api, keyring) {
  const transfer = api.tx.balances.transfer(keyring.bob.address, 12345);
  console.log('transfer as Call', transfer);
  console.log('transfer as Extrinsic', transfer); // simple "return the hash" variant

  console.log('hash:', (await transfer.signAndSend(keyring.alice)).toHex()); // passing options, but waiting for hash

  const nonce = await api.query.system.accountNonce(keyring.alice.address);
  (await api.tx.balances.transfer(keyring.bob.address, 12345).signAndSend(keyring.alice, {
    nonce
  })).toHex(); // just with the callback

  await api.tx.balances.transfer(keyring.bob.address, 12345).signAndSend(keyring.alice, (_ref2) => {
    let {
      status
    } = _ref2;
    console.log('transfer status:', status.type);
  }); // with options and the callback

  const nonce2 = await api.query.system.accountNonce(keyring.alice.address);
  const unsub2 = await api.tx.balances.transfer(keyring.bob.address, 12345).signAndSend(keyring.alice, {
    nonce: nonce2
  }, (_ref3) => {
    let {
      status
    } = _ref3;
    console.log('transfer status:', status.type);
    unsub2();
  });
}

async function main() {
  const api = await _api.ApiPromise.create();
  const keyring = (0, _testingPairs.default)();
  consts(api);
  derive(api);
  query(api, keyring);
  rpc(api);
  types();
  tx(api, keyring);
} // eslint-disable-next-line @typescript-eslint/unbound-method


main().catch(console.error);