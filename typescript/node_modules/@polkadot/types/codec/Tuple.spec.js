"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("../injector");

var _create = require("./create");

var _Metadata = _interopRequireDefault(require("../Metadata"));

var _static = _interopRequireDefault(require("../Metadata/static"));

var _Call = _interopRequireDefault(require("../primitive/Generic/Call"));

var _Text = _interopRequireDefault(require("../primitive/Text"));

var _U = _interopRequireDefault(require("../primitive/U32"));

var _U2 = _interopRequireDefault(require("../primitive/U128"));

var _Tuple = _interopRequireDefault(require("./Tuple"));

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
describe('Tuple', () => {
  let tuple;
  beforeEach(() => {
    tuple = new _Tuple.default([_Text.default, _U.default], ['bazzing', 69]);
  });
  describe('decoding', () => {
    const testDecode = (type, input) => it("can decode from ".concat(type), () => {
      const t = new _Tuple.default([_Text.default, _U.default], input);
      expect(t.toJSON()).toEqual(['bazzing', 69]);
    });

    testDecode('array', ['bazzing', 69]);
    testDecode('hex', '0x1c62617a7a696e6745000000');
    testDecode('Uint8Array', Uint8Array.from([28, 98, 97, 122, 122, 105, 110, 103, 69, 0, 0, 0]));
  });
  describe('encoding', () => {
    const testEncode = (to, expected) => it("can encode ".concat(to), () => {
      expect(tuple[to]()).toEqual(expected);
    });

    testEncode('toHex', '0x1c62617a7a696e6745000000');
    testEncode('toJSON', ['bazzing', 69]);
    testEncode('toU8a', Uint8Array.from([28, 98, 97, 122, 122, 105, 110, 103, 69, 0, 0, 0]));
    testEncode('toString', '["bazzing",69]');
  });
  it('creates from string types', () => {
    expect(new _Tuple.default(['Text', 'u32', _U.default], ['foo', 69, 42]).toString()).toEqual('["foo",69,42]');
  });
  it('creates properly via actual hex string', () => {
    _Call.default.injectMetadata(new _Metadata.default(_static.default));

    const test = new (_Tuple.default.with([(0, _create.ClassOf)('BlockNumber'), (0, _create.ClassOf)('VoteThreshold')]))('0x6219000001');
    expect(test[0].toNumber()).toEqual(6498);
    expect(test[1].toNumber()).toEqual(1);
  });
  it('exposes the Types', () => {
    expect(tuple.Types).toEqual(['Text', 'u32']);
  });
  it('exposes the Types (object creation)', () => {
    const test = new _Tuple.default({
      BlockNumber: (0, _create.ClassOf)('BlockNumber'),
      VoteThreshold: (0, _create.ClassOf)('VoteThreshold')
    }, []);
    expect(test.Types).toEqual(['BlockNumber', 'VoteThreshold']);
  });
  it('exposes filter', () => {
    expect(tuple.filter(v => v.toJSON() === 69)).toEqual([new _U.default(69)]);
  });
  it('exposes map', () => {
    expect(tuple.map(v => v.toString())).toEqual(['bazzing', '69']);
  });
  describe('utils', () => {
    it('compares against inputs', () => {
      expect(tuple.eq(['bazzing', 69])).toBe(true);
    });
    it('compares against inputs (mismatch)', () => {
      expect(tuple.eq(['bazzing', 72])).toBe(false);
    });
  });
  describe('toRawType', () => {
    it('generates sane value with array types', () => {
      expect(new _Tuple.default([_U2.default, (0, _create.ClassOf)('BlockNumber')]).toRawType()).toEqual('(u128,u32)');
    });
    it('generates sane value with object types', () => {
      expect(new _Tuple.default({
        number: _U2.default,
        blockNumber: (0, _create.ClassOf)('BlockNumber')
      }).toRawType()).toEqual('(u128,u32)');
    });
  });
});