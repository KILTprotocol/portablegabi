import { Codec, Constructor, InterfaceTypes } from '../types';
import AbstractArray from './AbstractArray';
/**
 * @name Vec
 * @description
 * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows
 * construction with the passed `Type` in the constructor. It is an extension to Array, providing
 * specific encoding/decoding on top of the base type.
 */
export default class Vec<T extends Codec> extends AbstractArray<T> {
    private _Type;
    constructor(Type: Constructor<T> | InterfaceTypes, value?: Vec<any> | Uint8Array | string | any[]);
    static decodeVec<T extends Codec>(Type: Constructor<T>, value: Vec<any> | Uint8Array | string | any[]): T[];
    static with<O extends Codec>(Type: Constructor<O> | InterfaceTypes): Constructor<Vec<O>>;
    /**
     * @description The type for the items
     */
    get Type(): string;
    /**
     * @description Finds the index of the value in the array
     */
    indexOf(_other?: any): number;
    /**
     * @description Returns the base runtime type name for this instance
     */
    toRawType(): string;
}
