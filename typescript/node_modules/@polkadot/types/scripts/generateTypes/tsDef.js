"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGetter = createGetter;
exports.default = generateTsDef;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _types = require("../../codec/types");

var _fs = _interopRequireDefault(require("fs"));

var _util = require("@polkadot/util");

var _create = require("../../codec/create");

var definitions = _interopRequireWildcard(require("../../interfaces/definitions"));

var _util2 = require("../util");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// helper to generate a `readonly <Name>: <Type>;` getter
function createGetter() {
  let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  let type = arguments.length > 1 ? arguments[1] : undefined;
  let imports = arguments.length > 2 ? arguments[2] : undefined;
  let doc = arguments.length > 3 ? arguments[3] : undefined;
  (0, _util2.setImports)(imports, [type]);
  return "  /** ".concat(doc || type, " */\n  readonly ").concat(name, ": ").concat(type, ";\n");
} // eslint-disable-next-line @typescript-eslint/no-unused-vars


function errorUnhandled(def, imports) {
  throw new Error("Generate: ".concat(name, ": Unhandled type ").concat(_types.TypeDefInfo[def.info]));
}

function tsBTreeMap(_ref, imports) {
  let {
    name: resultName,
    sub,
    type
  } = _ref;
  const [keyDef, valDef] = sub;
  (0, _util2.setImports)(imports, [type]);
  return (0, _util2.exportInterface)(resultName, (0, _util2.formatBTreeMap)(keyDef.type, valDef.type));
}

function tsCompact(_ref2, imports) {
  let {
    name: compactName,
    sub
  } = _ref2;
  const def = sub;
  (0, _util2.setImports)(imports, ['Compact']);

  switch (def.info) {
    case _types.TypeDefInfo.Plain:
      (0, _util2.setImports)(imports, [def.type]);
      return (0, _util2.exportType)(compactName, (0, _util2.formatCompact)(def.type));

    default:
      throw new Error("Enum: ".concat(compactName, ": Unhandled type ").concat(_types.TypeDefInfo[def.info]));
  }
}

function tsEnum(_ref3, imports) {
  let {
    name: enumName,
    sub
  } = _ref3;
  (0, _util2.setImports)(imports, ['Enum']);
  const keys = sub.map((_ref4, index) => {
    let {
      info,
      name = '',
      type
    } = _ref4;
    const getter = (0, _util.stringUpperFirst)((0, _util.stringCamelCase)(name.replace(' ', '_')));
    const [enumType, asGetter] = type === 'Null' ? ['', ''] : ["(".concat(type, ")"), createGetter("as".concat(getter), type, imports)];
    const isGetter = createGetter("is".concat(getter), 'boolean', imports, "".concat(index, ":: ").concat(name).concat(enumType));

    switch (info) {
      case _types.TypeDefInfo.Plain:
      case _types.TypeDefInfo.Vec:
        return "".concat(isGetter).concat(asGetter);

      default:
        throw new Error("Enum: ".concat(enumName, ": Unhandled type ").concat(_types.TypeDefInfo[info]));
    }
  });
  return (0, _util2.exportInterface)(enumName, 'Enum', keys.join(''));
}

function tsOption(_ref5, imports) {
  let {
    name: optionName,
    sub
  } = _ref5;
  const def = sub;
  (0, _util2.setImports)(imports, ['Option']);

  switch (def.info) {
    case _types.TypeDefInfo.Plain:
      (0, _util2.setImports)(imports, [def.type]);
      return (0, _util2.exportType)(optionName, (0, _util2.formatOption)(def.type));

    default:
      throw new Error("Enum: ".concat(optionName, ": Unhandled type ").concat(_types.TypeDefInfo[def.info]));
  }
}

function tsPlain(_ref6, imports) {
  let {
    name: plainName,
    type
  } = _ref6;
  (0, _util2.setImports)(imports, [type]);
  return (0, _util2.exportType)(plainName, type);
}

function tsResultGetter() {
  let resultName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  let getter = arguments.length > 1 ? arguments[1] : undefined;
  let {
    info,
    name = '',
    type
  } = arguments.length > 2 ? arguments[2] : undefined;
  let imports = arguments.length > 3 ? arguments[3] : undefined;
  const [resultType, asGetter] = type === 'Null' ? ['', ''] : ["(".concat(type, ")"), createGetter("as".concat(getter), type, imports)];
  const isGetter = createGetter("is".concat(getter), 'boolean', imports, "".concat(getter, ":: ").concat(name).concat(resultType));

  switch (info) {
    case _types.TypeDefInfo.Plain:
    case _types.TypeDefInfo.Vec:
      return "".concat(isGetter).concat(asGetter);

    default:
      throw new Error("Result: ".concat(resultName, ": Unhandled type ").concat(_types.TypeDefInfo[info]));
  }
}

function tsResult(_ref7, imports) {
  let {
    name: resultName,
    sub,
    type
  } = _ref7;
  const [okDef, errorDef] = sub;
  const inner = [tsResultGetter(resultName, 'Error', errorDef, imports), tsResultGetter(resultName, 'Ok', okDef, imports)].join('');
  (0, _util2.setImports)(imports, [type]);
  return (0, _util2.exportInterface)(resultName, (0, _util2.formatResult)(okDef.type, errorDef.type), inner);
}

function _tsStructGetterType(structName, _ref8, imports) {
  let {
    info,
    sub,
    type
  } = _ref8;

  let _type;

  switch (info) {
    case _types.TypeDefInfo.Compact:
      _type = sub.type;
      (0, _util2.setImports)(imports, ['Compact']);
      return [_type, (0, _util2.formatCompact)(_type)];

    case _types.TypeDefInfo.Option:
      _type = sub.type;
      (0, _util2.setImports)(imports, ['Option']);
      return [_type, (0, _util2.formatOption)(_type)];

    case _types.TypeDefInfo.Plain:
      return [type, type];

    case _types.TypeDefInfo.Vec:
      _type = sub.type;
      (0, _util2.setImports)(imports, ['Vec']);
      return [_type, (0, _util2.formatVec)(_type)];

    default:
      throw new Error("Struct: ".concat(structName, ": Unhandled type ").concat(_types.TypeDefInfo[info]));
  }
}

function tsSet(_ref9, imports) {
  let {
    name: setName,
    sub
  } = _ref9;
  (0, _util2.setImports)(imports, ['Set']);
  const types = sub.map((_ref10) => {
    let {
      name
    } = _ref10;
    return createGetter("is".concat(name), 'boolean', imports);
  });
  return (0, _util2.exportInterface)(setName, 'Set', types.join(''));
}

function tsStruct(_ref11, imports) {
  let {
    name: structName,
    sub
  } = _ref11;
  const keys = sub.map(typedef => {
    const [embedType, returnType] = _tsStructGetterType(structName, typedef, imports);

    (0, _util2.setImports)(imports, ['Struct', embedType]);
    return createGetter(typedef.name, returnType, imports);
  });
  return (0, _util2.exportInterface)(structName, 'Struct', keys.join(''));
}

function _tsTupleGetterType(tupleName, _ref12, imports) {
  let {
    info,
    sub,
    type
  } = _ref12;

  switch (info) {
    case _types.TypeDefInfo.Option:
      (0, _util2.setImports)(imports, ['Option', sub.type]);
      return type;

    case _types.TypeDefInfo.Plain:
      (0, _util2.setImports)(imports, [type]);
      return type;

    default:
      throw new Error("Struct: ".concat(tupleName, ": Unhandled type ").concat(_types.TypeDefInfo[info]));
  }
}

function tsTuple(_ref13, imports) {
  let {
    name: tupleName,
    sub
  } = _ref13;
  (0, _util2.setImports)(imports, ['ITuple']);
  const types = sub.map(typedef => _tsTupleGetterType(tupleName, typedef, imports));
  return (0, _util2.exportType)(tupleName, (0, _util2.formatTuple)(types));
}

function tsVec(_ref14, imports) {
  let {
    ext,
    info,
    name: vectorName,
    sub
  } = _ref14;
  const type = info === _types.TypeDefInfo.VecFixed ? ext.type : sub.type; // FIXME This should be a VecFixed
  // FIXME Technically Vec has length prefix, so for others this is not 100%

  if (info === _types.TypeDefInfo.VecFixed && type === 'u8') {
    (0, _util2.setImports)(imports, ['Codec']);
    return (0, _util2.exportType)(vectorName, 'Uint8Array, Codec');
  }

  (0, _util2.setImports)(imports, ['Vec', type]);
  return (0, _util2.exportType)(vectorName, (0, _util2.formatVec)(type));
}

function generateInterfaces(_ref15, imports) {
  let {
    types
  } = _ref15;
  // handlers are defined externally to use - this means that when we do a
  // `generators[typedef.info](...)` TS will show any unhandled types. Rather
  // we are being explicit in having no handlers where we do not support (yet)
  const generators = {
    [_types.TypeDefInfo.BTreeMap]: tsBTreeMap,
    [_types.TypeDefInfo.Compact]: tsCompact,
    [_types.TypeDefInfo.DoubleMap]: errorUnhandled,
    [_types.TypeDefInfo.Enum]: tsEnum,
    [_types.TypeDefInfo.Linkage]: errorUnhandled,
    [_types.TypeDefInfo.Null]: errorUnhandled,
    [_types.TypeDefInfo.Option]: tsOption,
    [_types.TypeDefInfo.Plain]: tsPlain,
    [_types.TypeDefInfo.Result]: tsResult,
    [_types.TypeDefInfo.Set]: tsSet,
    [_types.TypeDefInfo.Struct]: tsStruct,
    [_types.TypeDefInfo.Tuple]: tsTuple,
    [_types.TypeDefInfo.Vec]: tsVec,
    [_types.TypeDefInfo.VecFixed]: tsVec
  };
  return Object.entries(types).map((_ref16) => {
    let [name, type] = _ref16;
    const def = (0, _create.getTypeDef)((0, _util.isString)(type) ? type.toString() : JSON.stringify(type), {
      name
    });
    return [name, generators[def.info](def, imports)];
  });
}

function generateTsDefFor(defName, _ref17) {
  let {
    types
  } = _ref17;

  const imports = _objectSpread({}, (0, _util2.createImports)({
    types
  }), {
    interfaces: []
  });

  const interfaces = generateInterfaces({
    types
  }, imports);
  const sortedDefs = interfaces.sort((a, b) => a[0].localeCompare(b[0])).map((_ref18) => {
    let [, definition] = _ref18;
    return definition;
  }).join('\n\n');
  const header = (0, _util2.createImportCode)(_util2.HEADER, [{
    file: '@polkadot/types/types',
    types: Object.keys(imports.typesTypes)
  }, {
    file: '@polkadot/types/codec',
    types: Object.keys(imports.codecTypes).filter(name => name !== 'Tuple')
  }, {
    file: '@polkadot/types/primitive',
    types: Object.keys(imports.primitiveTypes)
  }, ...Object.keys(imports.localTypes).map(moduleName => ({
    file: "@polkadot/types/interfaces/".concat(moduleName),
    types: Object.keys(imports.localTypes[moduleName])
  }))]);
  Object.entries(imports.localTypes).forEach((_ref19) => {
    let [moduleName, typeMap] = _ref19;
    const types = Object.keys(typeMap).sort();

    if (types.length) {
      console.log("\timport { ".concat(types.join(', '), " } from '../").concat(moduleName, "'"));
    }
  });

  _fs.default.writeFileSync("packages/types/src/interfaces/".concat(defName, "/types.ts"), header.concat(sortedDefs).concat(_util2.FOOTER), {
    flag: 'w'
  });

  _fs.default.writeFileSync("packages/types/src/interfaces/".concat(defName, "/index.ts"), _util2.HEADER.concat('export * from \'./types\';').concat(_util2.FOOTER), {
    flag: 'w'
  });
}

function generateTsDef() {
  Object.entries(definitions).forEach((_ref20) => {
    let [defName, obj] = _ref20;
    console.log("Extracting interfaces for ".concat(defName));
    generateTsDefFor(defName, obj);
  });
  console.log('Writing interfaces/types.ts');

  _fs.default.writeFileSync('packages/types/src/interfaces/types.ts', _util2.HEADER.concat(Object.keys(definitions).map(moduleName => "export * from './".concat(moduleName, "/types';")).join('\n')).concat(_util2.FOOTER), {
    flag: 'w'
  });

  _fs.default.writeFileSync('packages/types/src/interfaces/index.ts', _util2.HEADER.concat('export * from \'./types\';').concat(_util2.FOOTER), {
    flag: 'w'
  });
}