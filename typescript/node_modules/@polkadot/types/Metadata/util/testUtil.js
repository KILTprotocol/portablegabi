"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeLatestSubstrate = decodeLatestSubstrate;
exports.toLatest = toLatest;
exports.defaultValues = defaultValues;

require("../../injector");

var _create = require("../../codec/create");

var _Metadata = _interopRequireDefault(require("../Metadata"));

var _Call = _interopRequireDefault(require("../../primitive/Generic/Call"));

var _getUniqTypes = _interopRequireDefault(require("./getUniqTypes"));

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.

/**
 * Given the static `rpcData` and the `staticSubstrate` JSON file, Metadata
 * should decode `rpcData` and output `staticSubstrate`.
 */
function decodeLatestSubstrate(version, rpcData, staticSubstrate) {
  it('decodes latest substrate properly', () => {
    const metadata = new _Metadata.default(rpcData);
    console.error(JSON.stringify(metadata.toJSON()));
    expect(metadata.version).toBe(version);
    expect(metadata["asV".concat(version)].modules.length).not.toBe(0);
    expect(metadata.toJSON()).toEqual(staticSubstrate);
  });
}
/**
 * Given a `version`, MetadataLatest and MetadataV{version} should output the same
 * unique types.
 */


function toLatest(version, rpcData) {
  it("converts v".concat(version, " to v8"), () => {
    const metadata = new _Metadata.default(rpcData)["asV".concat(version)];
    const metadataV8 = new _Metadata.default(rpcData).asLatest;
    expect((0, _getUniqTypes.default)(metadata, true)).toEqual((0, _getUniqTypes.default)(metadataV8, true));
  });
}
/**
 * Given a Metadata, no type should throw when given its fallback value.
 */


function defaultValues(rpcData) {
  describe('storage with default values', () => {
    const metadata = new _Metadata.default(rpcData);

    _Call.default.injectMetadata(metadata);

    metadata.asLatest.modules.filter((_ref) => {
      let {
        storage
      } = _ref;
      return storage.isSome;
    }).forEach(mod => {
      mod.storage.unwrap().items.forEach((_ref2) => {
        let {
          fallback,
          name,
          type
        } = _ref2;
        it("creates default types for ".concat(mod.name, ".").concat(name, ", type ").concat(type), () => {
          expect(() => (0, _create.createTypeUnsafe)(type.toString(), [fallback])).not.toThrow();
        });
      });
    });
  });
}