"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.all = all;

var _bn = _interopRequireDefault(require("bn.js"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _types = require("@polkadot/types");

var _util = require("@polkadot/util");

var _util2 = require("../util");

// Copyright 2017-2019 @polkadot/api-derive authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
function calcBalances(_ref) {
  let [accountId, bestNumber, [freeBalance, reservedBalance, locks, vesting], accountNonce] = _ref;
  let lockedBalance = (0, _types.createType)('Balance');
  let lockedBreakdown = [];

  if (Array.isArray(locks)) {
    // only get the locks that are valid until passed the current block
    lockedBreakdown = locks.filter((_ref2) => {
      let {
        until
      } = _ref2;
      return bestNumber && until.gt(bestNumber);
    }); // get the maximum of the locks according to https://github.com/paritytech/substrate/blob/master/srml/balances/src/lib.rs#L699

    if (lockedBreakdown.length) {
      lockedBalance = (0, _types.createType)('Balance', (0, _util.bnMax)(...lockedBreakdown.map((_ref3) => {
        let {
          amount
        } = _ref3;
        return amount;
      })));
    }
  } // offset = balance locked at genesis, perBlock is the unlock amount


  const {
    offset: vestingTotal,
    perBlock
  } = vesting.unwrapOr((0, _types.createType)('VestingSchedule'));
  const vestedNow = (0, _types.createType)('Balance', perBlock.mul(bestNumber));
  const vestedBalance = (0, _types.createType)('Balance', vestedNow.gt(vestingTotal) ? new _bn.default(0) : (0, _util.bnMax)(new _bn.default(0), freeBalance.sub(vestingTotal).add(vestedNow)));
  const availableBalance = (0, _types.createType)('Balance', (0, _util.bnMax)(new _bn.default(0), (vestedBalance.gtn(0) ? vestedBalance : freeBalance).sub(lockedBalance)));
  return {
    accountId,
    accountNonce,
    availableBalance,
    freeBalance,
    lockedBalance,
    lockedBreakdown,
    reservedBalance,
    vestedBalance,
    vestingTotal,
    votingBalance: (0, _types.createType)('Balance', freeBalance.add(reservedBalance))
  };
}

function queryBalances(api, accountId) {
  return api.queryMulti([[api.query.balances.freeBalance, accountId], [api.query.balances.reservedBalance, accountId], [api.query.balances.locks, accountId], [api.query.balances.vesting, accountId]]);
}
/**
 * @name all
 * @param {( AccountIndex | AccountId | Address | string )} address - An accounts Id in different formats.
 * @returns An object containing the results of various balance queries
 * @example
 * <BR>
 *
 * ```javascript
 * const ALICE = 'F7Hs';
 *
 * api.derive.balances.all(ALICE, ({ accountId, lockedBalance }) => {
 *   console.log(`The account ${accountId} has a locked balance ${lockedBalance} units.`);
 * });
 * ```
 */


function all(api) {
  return address => api.derive.accounts.info(address).pipe((0, _operators.switchMap)((_ref4) => {
    let {
      accountId
    } = _ref4;
    return accountId ? (0, _rxjs.combineLatest)([(0, _rxjs.of)(accountId), api.derive.chain.bestNumber(), queryBalances(api, accountId), // FIXME This is having issues with Kusama, only use accountNonce atm
    // api.rpc.account && api.rpc.account.nextIndex
    //   ? api.rpc.account.nextIndex(accountId)
    //   // otherwise we end up with this: type 'Codec | Index' is not assignable to type 'Index'.
    //   : api.query.system.accountNonce<Index>(accountId)
    api.query.system.accountNonce(accountId)]) : (0, _rxjs.of)([(0, _types.createType)('AccountId'), (0, _types.createType)('BlockNumber'), [(0, _types.createType)('Balance'), (0, _types.createType)('Balance'), (0, _types.createType)('Vec<BalanceLock>'), (0, _types.createType)('Option<VestingSchedule>', null)], (0, _types.createType)('Index')]);
  }), (0, _operators.map)(calcBalances), (0, _util2.drr)());
}