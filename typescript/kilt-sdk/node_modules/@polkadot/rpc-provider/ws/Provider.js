"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

require("./polyfill");

var _eventemitter = _interopRequireDefault(require("eventemitter3"));

var _util = require("@polkadot/util");

var _coder = _interopRequireDefault(require("../coder"));

var _defaults = _interopRequireDefault(require("../defaults"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const ALIASSES = {
  chain_finalisedHead: 'chain_finalizedHead',
  chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',
  chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'
};
const l = (0, _util.logger)('api-ws');
/**
 * # @polkadot/rpc-provider/ws
 *
 * @name WsProvider
 *
 * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.
 *
 * @example
 * <BR>
 *
 * ```javascript
 * import Api from '@polkadot/api/promise';
 * import WsProvider from '@polkadot/rpc-provider/ws';
 *
 * const provider = new WsProvider('ws://127.0.0.1:9944');
 * const api = new Api(provider);
 * ```
 *
 * @see [[HttpProvider]]
 */

class WsProvider {
  /**
   * @param {string}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`
   * @param {boolean} autoConnect Whether to connect automatically or not.
   */
  constructor() {
    let endpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _defaults.default.WS_URL;
    let autoConnect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    this._eventemitter = void 0;
    this._isConnected = false;
    this.autoConnect = void 0;
    this.coder = void 0;
    this.endpoint = void 0;
    this.handlers = void 0;
    this.queued = void 0;
    this.subscriptions = void 0;
    this.waitingForId = void 0;
    this.websocket = void 0;

    this.onSocketClose = event => {
      if (this.autoConnect) {
        l.error("disconnected from ".concat(this.endpoint, " code: '").concat(event.code, "' reason: '").concat(event.reason, "'"));
      }

      this._isConnected = false;
      this.emit('disconnected');

      if (this.autoConnect) {
        setTimeout(() => {
          this.connect();
        }, 1000);
      }
    };

    this.onSocketError = error => {
      l.debug(() => ['socket error', error]);
      this.emit('error', error);
    };

    this.onSocketMessage = message => {
      l.debug(() => ['received', message.data]);
      const response = JSON.parse(message.data);
      return (0, _util.isUndefined)(response.method) ? this.onSocketMessageResult(response) : this.onSocketMessageSubscribe(response);
    };

    this.onSocketMessageResult = response => {
      const handler = this.handlers[response.id];

      if (!handler) {
        l.debug(() => "Unable to find handler for id=".concat(response.id));
        return;
      }

      try {
        const {
          method,
          params,
          subscription
        } = handler;
        const result = this.coder.decodeResponse(response); // first send the result - in case of subs, we may have an update
        // immediately if we have some queued results already

        handler.callback(null, result);

        if (subscription) {
          const subId = "".concat(subscription.type, "::").concat(result);
          this.subscriptions[subId] = _objectSpread({}, subscription, {
            method,
            params
          }); // if we have a result waiting for this subscription already

          if (this.waitingForId[subId]) {
            this.onSocketMessageSubscribe(this.waitingForId[subId]);
          }
        }
      } catch (error) {
        handler.callback(error, undefined);
      }

      delete this.handlers[response.id];
    };

    this.onSocketMessageSubscribe = response => {
      const method = ALIASSES[response.method] || response.method;
      const subId = "".concat(method, "::").concat(response.params.subscription);
      const handler = this.subscriptions[subId];

      if (!handler) {
        // store the JSON, we could have out-of-order subid coming in
        this.waitingForId[subId] = response;
        l.debug(() => "Unable to find handler for subscription=".concat(subId));
        return;
      } // housekeeping


      delete this.waitingForId[subId];

      try {
        const result = this.coder.decodeResponse(response);
        handler.callback(null, result);
      } catch (error) {
        handler.callback(error, undefined);
      }
    };

    this.onSocketOpen = () => {
      (0, _util.assert)(!(0, _util.isNull)(this.websocket), 'WebSocket cannot be null in onOpen');
      l.debug(() => ['connected to', this.endpoint]);
      this._isConnected = true;
      this.emit('connected');
      this.sendQueue();
      this.resubscribe();
      return true;
    };

    (0, _util.assert)(/^(wss|ws):\/\//.test(endpoint), "Endpoint should start with 'ws://', received '".concat(endpoint, "'"));
    this._eventemitter = new _eventemitter.default();
    this.autoConnect = autoConnect;
    this.coder = new _coder.default();
    this.endpoint = endpoint;
    this.handlers = {};
    this.queued = {};
    this.subscriptions = {};
    this.waitingForId = {};
    this.websocket = null;

    if (autoConnect) {
      this.connect();
    }
  }
  /**
   * @summary `true` when this provider supports subscriptions
   */


  get hasSubscriptions() {
    return true;
  }
  /**
   * @description Returns a clone of the object
   */


  clone() {
    return new WsProvider(this.endpoint);
  }
  /**
   * @summary Manually connect
   * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may
   * connect manually using this method.
   */


  connect() {
    try {
      this.websocket = new WebSocket(this.endpoint);
      this.websocket.onclose = this.onSocketClose;
      this.websocket.onerror = this.onSocketError;
      this.websocket.onmessage = this.onSocketMessage;
      this.websocket.onopen = this.onSocketOpen;
    } catch (error) {
      l.error(error);
    }
  }
  /**
   * @description Manually disconnect from the connection, clearing autoconnect logic
   */


  disconnect() {
    if ((0, _util.isNull)(this.websocket)) {
      throw new Error('Cannot disconnect on a non-open websocket');
    } // switch off autoConnect, we are in manual mode now


    this.autoConnect = false; // 1000 - Normal closure; the connection successfully completed

    this.websocket.close(1000);
    this.websocket = null;
  }
  /**
   * @summary Whether the node is connected or not.
   * @return {boolean} true if connected
   */


  isConnected() {
    return this._isConnected;
  }
  /**
   * @summary Listens on events after having subscribed using the [[subscribe]] function.
   * @param  {ProviderInterfaceEmitted} type Event
   * @param  {ProviderInterfaceEmitCb}  sub  Callback
   */


  on(type, sub) {
    this._eventemitter.on(type, sub);
  }
  /**
   * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.
   * @param method The RPC methods to execute
   * @param params Encoded paramaters as appliucable for the method
   * @param subscription Subscription details (internally used)
   */


  send(method, params, subscription) {
    return new Promise((resolve, reject) => {
      try {
        const json = this.coder.encodeJson(method, params);
        const id = this.coder.getId();

        const callback = (error, result) => {
          error ? reject(error) : resolve(result);
        };

        l.debug(() => ['calling', method, json]);
        this.handlers[id] = {
          callback,
          method,
          params,
          subscription
        };

        if (this.isConnected() && !(0, _util.isNull)(this.websocket)) {
          this.websocket.send(json);
        } else {
          this.queued[id] = json;
        }
      } catch (error) {
        reject(error);
      }
    });
  }
  /**
   * @name subscribe
   * @summary Allows subscribing to a specific event.
   * @param  {string}                     type     Subscription type
   * @param  {string}                     method   Subscription method
   * @param  {any[]}                 params   Parameters
   * @param  {ProviderInterfaceCallback} callback Callback
   * @return {Promise<number>}                     Promise resolving to the dd of the subscription you can use with [[unsubscribe]].
   *
   * @example
   * <BR>
   *
   * ```javascript
   * const provider = new WsProvider('ws://127.0.0.1:9944');
   * const rpc = new Rpc(provider);
   *
   * rpc.state.subscribeStorage([[storage.balances.freeBalance, <Address>]], (_, values) => {
   *   console.log(values)
   * }).then((subscriptionId) => {
   *   console.log('balance changes subscription id: ', subscriptionId)
   * })
   * ```
   */


  async subscribe(type, method, params, callback) {
    const id = await this.send(method, params, {
      callback,
      type
    });
    return id;
  }
  /**
   * @summary Allows unsubscribing to subscriptions made with [[subscribe]].
   */


  async unsubscribe(type, method, id) {
    const subscription = "".concat(type, "::").concat(id); // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub
    // the assigned id now does not match what the API user originally received. It has
    // a slight complication in solving - since we cannot rely on the send id, but rather
    // need to find the actual subscription id to map it

    if ((0, _util.isUndefined)(this.subscriptions[subscription])) {
      l.debug(() => "Unable to find active subscription=".concat(subscription));
      return false;
    }

    delete this.subscriptions[subscription];
    const result = await this.send(method, [id]);
    return result;
  }

  emit(type) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    this._eventemitter.emit(type, ...args);
  }

  resubscribe() {
    const subscriptions = this.subscriptions;
    this.subscriptions = {}; // eslint-disable-next-line @typescript-eslint/no-misused-promises

    Object.keys(subscriptions).forEach(async id => {
      const {
        callback,
        method,
        params,
        type
      } = subscriptions[id]; // only re-create subscriptions which are not in author (only area where
      // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'
      // are not included (and will not be re-broadcast)

      if (type.startsWith('author_')) {
        return;
      }

      try {
        await this.subscribe(type, method, params, callback);
      } catch (error) {
        l.error(error);
      }
    });
  }

  sendQueue() {
    Object.keys(this.queued).forEach(id => {
      try {
        // we have done the websocket check in onSocketOpen, if an issue, will catch it
        this.websocket.send(this.queued[id]);
        delete this.queued[id];
      } catch (error) {
        l.error(error);
      }
    });
  }

}

exports.default = WsProvider;