"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toV1;

var _util = require("@polkadot/util");

var _codec = require("../../codec");

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
function toV1Calls(_ref) {
  let {
    module: {
      call: {
        functions
      }
    }
  } = _ref;
  return functions.length ? new _codec.Option(_codec.Vec.with('FunctionMetadataV1'), functions) : new _codec.Option(_codec.Vec.with('FunctionMetadataV1'));
}

function toV1Events(metadataV0, prefix) {
  const events = metadataV0.outerEvent.events.find(event => event[0].eq(prefix));
  return events ? new _codec.Option(_codec.Vec.with('EventMetadataV1'), events[1]) : new _codec.Option(_codec.Vec.with('EventMetadataV1'));
}

function toV1Storage(_ref2) {
  let {
    storage
  } = _ref2;
  return storage.isSome ? new _codec.Option('Vec<StorageFunctionMetadataV1>', storage.unwrap().functions) : new _codec.Option('Vec<StorageFunctionMetadataV1>');
}
/**
 * Function that converts MetadataV0 to MetadataV1
 */


function toV1(metadataV0) {
  return (0, _codec.createType)('MetadataV1', {
    modules: metadataV0.modules.map(mod => {
      // The prefix of this module (capitalized)
      const prefix = mod.storage.isSome ? mod.storage.unwrap().prefix.toString() : (0, _util.stringUpperFirst)(mod.prefix.toString()); // If this module doesn't have storage, we just assume the prefix is the name capitalized

      return (0, _codec.createType)('ModuleMetadataV1', {
        name: mod.prefix,
        // Not capitalized
        prefix,
        // Capitalized
        storage: toV1Storage(mod),
        calls: toV1Calls(mod),
        events: toV1Events(metadataV0, mod.prefix)
      });
    })
  });
}