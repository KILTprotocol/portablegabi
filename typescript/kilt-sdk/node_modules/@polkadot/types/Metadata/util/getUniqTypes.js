"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getUniqTypes;

var _flattenUniq = _interopRequireDefault(require("./flattenUniq"));

var _validateTypes = _interopRequireDefault(require("./validateTypes"));

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
function unwrapCalls(mod) {
  return mod.calls ? mod.calls.unwrapOr([]) // V0
  : mod.module ? mod.module.call.functions : [];
}

function getCallNames(_ref) {
  let {
    modules
  } = _ref;
  return modules.map(mod => unwrapCalls(mod).map((_ref2) => {
    let {
      args
    } = _ref2;
    return args.map(arg => arg.type.toString());
  }));
}

function getConstantNames(_ref3) {
  let {
    modules
  } = _ref3;
  return modules.map((_ref4) => {
    let {
      constants
    } = _ref4;
    return constants ? constants.map(constant => constant.type.toString()) : [];
  });
}

function unwrapEvents(events) {
  if (!events) {
    return [];
  }

  return events.unwrapOr([]);
}

function getEventNames(_ref5) {
  let {
    modules,
    outerEvent
  } = _ref5;

  const mapArg = (_ref6) => {
    let {
      args
    } = _ref6;
    return args.map(arg => arg.toString());
  }; // V0


  if (outerEvent) {
    return outerEvent.events.map((_ref7) => {
      let [, events] = _ref7;
      return events.map(mapArg);
    });
  } // V1+


  return modules.map((_ref8) => {
    let {
      events
    } = _ref8;
    return unwrapEvents(events).map(mapArg);
  });
}

function unwrapStorage(storage) {
  if (!storage) {
    return [];
  }

  const data = storage.unwrapOr([]);
  return Array.isArray(data) ? data : data.items || data.functions;
}

function getStorageNames(_ref9) {
  let {
    modules
  } = _ref9;
  return modules.map((_ref10) => {
    let {
      storage
    } = _ref10;
    return unwrapStorage(storage).map((_ref11) => {
      let {
        type
      } = _ref11;

      if (type.isDoubleMap && type.asDoubleMap) {
        return [type.asDoubleMap.key1.toString(), type.asDoubleMap.key2.toString(), type.asDoubleMap.value.toString()];
      } else if (type.isMap) {
        return [type.asMap.key.toString(), type.asMap.value.toString()];
      } else {
        return [type.asType.toString()];
      }
    });
  });
}

function getUniqTypes(meta, throwError) {
  const types = (0, _flattenUniq.default)([getCallNames(meta), getConstantNames(meta), getEventNames(meta), getStorageNames(meta)]);
  (0, _validateTypes.default)(types, throwError);
  return types;
}