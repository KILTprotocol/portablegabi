import { SignOptions } from '@polkadot/keyring/types';
import { FunctionMetadataLatest } from './interfaces/metadata';
import { Balance, EcdsaSignature, Ed25519Signature, Index, Sr25519Signature } from './interfaces/runtime';
import BN from 'bn.js';
import Compact from './codec/Compact';
import U8a from './codec/U8a';
import { InterfaceRegistry } from './interfaceRegistry';
import Call from './primitive/Generic/Call';
import Address from './primitive/Generic/Address';
export * from './codec/types';
export declare type InterfaceTypes = keyof InterfaceRegistry;
export interface CallFunction {
    (...args: any[]): Call;
    callIndex: Uint8Array;
    meta: FunctionMetadataLatest;
    method: string;
    section: string;
    toJSON: () => any;
}
export declare type Calls = Record<string, CallFunction>;
export declare type ModulesWithCalls = Record<string, Calls>;
export interface IKeyringPair {
    address: string;
    publicKey: Uint8Array;
    sign: (data: Uint8Array, options?: SignOptions) => Uint8Array;
}
interface CodecArgArray extends Array<CodecArg> {
}
export declare type CodecArg = Codec | BN | boolean | string | Uint8Array | boolean | number | string | undefined | CodecArgArray | CodecArgObject;
export declare type Callback<T> = (result: T) => void | Promise<void>;
interface CodecArgObject {
    [index: string]: CodecArg;
}
export declare type AnyFunction = (...args: any[]) => any;
export declare type AnyNumber = BN | Uint8Array | number | string;
export declare type AnyString = string | string;
export declare type AnyU8a = Uint8Array | number[] | string;
export interface AnyJsonObject extends Record<string, AnyJson> {
}
export interface AnyJsonArray extends Array<AnyJson> {
}
export declare type AnyJson = string | number | boolean | null | undefined | AnyJsonObject | AnyJsonArray;
/**
 * @name Codec
 * @description
 * The base Codec interface. All types implement the interface provided here. Additionally
 * implementors can add their own specific interfaces and helpres with getters and functions.
 * The Codec Base is however required for operating as an encoding/decoding layer
 */
export interface Codec {
    /**
     * @description The length of the value when encoded as a Uint8Array
     */
    encodedLength: number;
    /**
     * @description Returns a hash of the value
     */
    hash: IHash;
    /**
     * @description Checks if the value is an empty value
     */
    isEmpty: boolean;
    /**
     * @description Compares the value of the input to see if there is a match
     */
    eq(other?: any): boolean;
    /**
     * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
     */
    toHex(isLe?: boolean): string;
    /**
     * @description Converts the Object to JSON, typically used for RPC transfers
     */
    toJSON(): AnyJson;
    /**
     * @description Returns the base runtime type name for this instance
     */
    toRawType(): string;
    /**
     * @description Returns the string representation of the value
     */
    toString(): string;
    /**
     * @description Encodes the value as a Uint8Array as per the SCALE specifications
     * @param isBare true when the value has none of the type-specific prefixes (internal)
     */
    toU8a(isBare?: boolean): Uint8Array;
}
export interface IHash extends U8a {
}
export declare type CodecTo = 'toHex' | 'toJSON' | 'toString' | 'toU8a';
export interface Constructor<T = Codec> {
    new (...value: any[]): T;
}
export declare type ConstructorDef<T = Codec> = Record<string, Constructor<T>>;
export declare type RegistryTypes = Record<string, Constructor | string | Record<string, string> | {
    _enum: string[] | Record<string, string | null>;
} | {
    _set: Record<string, number>;
}>;
export interface RuntimeVersionInterface {
    readonly apis: any[];
    readonly authoringVersion: BN;
    readonly implName: String;
    readonly implVersion: BN;
    readonly specName: String;
    readonly specVersion: BN;
}
export interface SignatureOptions {
    blockHash: AnyU8a;
    era?: IExtrinsicEra;
    genesisHash: AnyU8a;
    nonce: AnyNumber;
    runtimeVersion: RuntimeVersionInterface;
    tip?: AnyNumber;
}
export declare type ArgsDef = Record<string, Constructor>;
export declare type ITuple<Sub extends Codec[]> = Sub & Codec;
export interface IMethod extends Codec {
    readonly args: Codec[];
    readonly argsDef: ArgsDef;
    readonly callIndex: Uint8Array;
    readonly data: Uint8Array;
    readonly hash: IHash;
    readonly hasOrigin: boolean;
    readonly meta: FunctionMetadataLatest;
}
interface ExtrinsicSignatureBase {
    readonly isSigned: boolean;
    readonly era: IExtrinsicEra;
    readonly nonce: Compact<Index>;
    readonly signature: EcdsaSignature | Ed25519Signature | Sr25519Signature;
    readonly signer: Address;
    readonly tip: Compact<Balance>;
}
export interface ExtrinsicPayloadValue {
    blockHash: AnyU8a;
    era: AnyU8a | IExtrinsicEra;
    genesisHash: AnyU8a;
    method: AnyU8a | IMethod;
    nonce: AnyNumber;
    specVersion: AnyNumber;
    tip: AnyNumber;
}
export interface IExtrinsicSignature extends ExtrinsicSignatureBase, Codec {
    addSignature(signer: Address | Uint8Array | string, signature: Uint8Array | string, payload: Uint8Array | string): IExtrinsicSignature;
    sign(method: Call, account: IKeyringPair, options: SignatureOptions): IExtrinsicSignature;
}
export interface IExtrinsicEra extends Codec {
    asImmortalEra: Codec;
    asMortalEra: Codec;
}
interface IExtrinsicSignable<T> {
    addSignature(signer: Address | Uint8Array | string, signature: Uint8Array | string, payload: ExtrinsicPayloadValue | Uint8Array | string): T;
    sign(account: IKeyringPair, options: SignatureOptions): T;
}
export interface IExtrinsicImpl extends IExtrinsicSignable<IExtrinsicImpl>, Codec {
    readonly method: Call;
    readonly signature: IExtrinsicSignature;
    readonly version: number;
}
export interface IExtrinsic extends IExtrinsicSignable<IExtrinsic>, ExtrinsicSignatureBase, IMethod {
    readonly length: number;
    readonly method: Call;
    readonly type: number;
    readonly version: number;
}
export interface SignerPayloadJSON {
    /**
     * @description The ss-58 encoded address
     */
    address: string;
    /**
     * @description The checkpoint hash of the block, in hex
     */
    blockHash: string;
    /**
     * @description The checkpoint block number, in hex
     */
    blockNumber: string;
    /**
     * @description The era for this transaction, in hex
     */
    era: string;
    /**
     * @description The genesis hash of the chain, in hex
     */
    genesisHash: string;
    /**
     * @description The encoded method (with arguments) in hex
     */
    method: string;
    /**
     * @description The nonce for this transaction, in hex
     */
    nonce: string;
    /**
     * @description The current spec version for  the runtime
     */
    specVersion: string;
    /**
     * @description The tip for this transaction, in hex
     */
    tip: string;
    /**
     * @description The version of the extrinsic we are dealing with
     */
    version: number;
}
export interface SignerPayloadRawBase {
    /**
     * @description The hex-encoded data for this request
     */
    data: string;
    /**
     * @description The type of the contained data
     */
    type?: 'bytes' | 'payload';
}
export interface SignerPayloadRaw extends SignerPayloadRawBase {
    /**
     * @description The ss-58 encoded address
     */
    address: string;
    /**
     * @description The type of the contained data
     */
    type: 'bytes' | 'payload';
}
export interface ISignerPayload {
    toPayload(): SignerPayloadJSON;
    toRaw(): SignerPayloadRaw;
}
