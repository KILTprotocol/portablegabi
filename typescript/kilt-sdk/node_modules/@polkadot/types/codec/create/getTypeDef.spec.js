"use strict";

require("../../injector");

var _types = require("../types");

var _ = require(".");

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
describe('getTypeDef', () => {
  it('does not allow invalid tuples, end )', () => {
    expect(() => (0, _.getTypeDef)('(u64, u32')).toThrow(/Expected '\(' closing with '\)'/);
  });
  it('does not allow invalid vectors, end >', () => {
    expect(() => (0, _.getTypeDef)('Vec<u64')).toThrow(/Unable to find closing matching/);
  });
  it('maps empty tuples to Null', () => {
    expect((0, _.getTypeDef)('()')).toEqual({
      info: _types.TypeDefInfo.Plain,
      type: 'Null'
    });
  });
  it('properly decodes a BTreeMap<u32, Text>', () => {
    expect((0, _.getTypeDef)('BTreeMap<u32, Text>')).toEqual({
      info: _types.TypeDefInfo.BTreeMap,
      type: 'BTreeMap<u32,Text>',
      sub: [{
        info: _types.TypeDefInfo.Plain,
        type: 'u32'
      }, {
        info: _types.TypeDefInfo.Plain,
        type: 'Text'
      }]
    });
  });
  it('properly decodes a Result<u32, Text>', () => {
    expect((0, _.getTypeDef)('Result<u32, Text>')).toEqual({
      info: _types.TypeDefInfo.Result,
      type: 'Result<u32,Text>',
      sub: [{
        info: _types.TypeDefInfo.Plain,
        type: 'u32'
      }, {
        info: _types.TypeDefInfo.Plain,
        type: 'Text'
      }]
    });
  });
  it('properly decodes a Result<Result<(), u32>, Text>', () => {
    expect((0, _.getTypeDef)('Result<Result<Null,u32>,Text>')).toEqual({
      info: _types.TypeDefInfo.Result,
      type: 'Result<Result<Null,u32>,Text>',
      sub: [{
        info: _types.TypeDefInfo.Result,
        type: 'Result<Null,u32>',
        sub: [{
          info: _types.TypeDefInfo.Plain,
          type: 'Null'
        }, {
          info: _types.TypeDefInfo.Plain,
          type: 'u32'
        }]
      }, {
        info: _types.TypeDefInfo.Plain,
        type: 'Text'
      }]
    });
  });
  it('returns a type structure', () => {
    expect((0, _.getTypeDef)('(u32, Compact<u32>, Vec<u64>, Option<u128>, DoubleMap<u128>, (Text,Vec<(Bool,u128)>))')).toEqual({
      info: _types.TypeDefInfo.Tuple,
      type: '(u32,Compact<u32>,Vec<u64>,Option<u128>,DoubleMap<u128>,(Text,Vec<(Bool,u128)>))',
      sub: [{
        info: _types.TypeDefInfo.Plain,
        type: 'u32'
      }, {
        info: _types.TypeDefInfo.Compact,
        type: 'Compact<u32>',
        sub: {
          info: _types.TypeDefInfo.Plain,
          type: 'u32'
        }
      }, {
        info: _types.TypeDefInfo.Vec,
        type: 'Vec<u64>',
        sub: {
          info: _types.TypeDefInfo.Plain,
          type: 'u64'
        }
      }, {
        info: _types.TypeDefInfo.Option,
        type: 'Option<u128>',
        sub: {
          info: _types.TypeDefInfo.Plain,
          type: 'u128'
        }
      }, {
        info: _types.TypeDefInfo.DoubleMap,
        type: 'DoubleMap<u128>',
        sub: {
          info: _types.TypeDefInfo.Plain,
          type: 'u128'
        }
      }, {
        info: _types.TypeDefInfo.Tuple,
        type: '(Text,Vec<(Bool,u128)>)',
        sub: [{
          info: _types.TypeDefInfo.Plain,
          type: 'Text'
        }, {
          info: _types.TypeDefInfo.Vec,
          type: 'Vec<(Bool,u128)>',
          sub: {
            info: _types.TypeDefInfo.Tuple,
            type: '(Bool,u128)',
            sub: [{
              info: _types.TypeDefInfo.Plain,
              type: 'Bool'
            }, {
              info: _types.TypeDefInfo.Plain,
              type: 'u128'
            }]
          }
        }]
      }]
    });
  });
  it('returns a type structure (sanitized)', () => {
    expect((0, _.getTypeDef)('Vec<(Box<PropIndex>, Proposal,Lookup::Target)>')).toEqual({
      info: _types.TypeDefInfo.Vec,
      type: 'Vec<(PropIndex,Proposal,AccountId)>',
      sub: {
        info: _types.TypeDefInfo.Tuple,
        type: '(PropIndex,Proposal,AccountId)',
        sub: [{
          info: _types.TypeDefInfo.Plain,
          type: 'PropIndex'
        }, {
          info: _types.TypeDefInfo.Plain,
          type: 'Proposal'
        }, {
          info: _types.TypeDefInfo.Plain,
          type: 'AccountId'
        }]
      }
    });
  });
  it('returns a type structure (actual)', () => {
    expect((0, _.getTypeDef)('Vec<(PropIndex, Proposal, AccountId)>')).toEqual({
      info: _types.TypeDefInfo.Vec,
      type: 'Vec<(PropIndex,Proposal,AccountId)>',
      sub: {
        info: _types.TypeDefInfo.Tuple,
        type: '(PropIndex,Proposal,AccountId)',
        sub: [{
          info: _types.TypeDefInfo.Plain,
          type: 'PropIndex'
        }, {
          info: _types.TypeDefInfo.Plain,
          type: 'Proposal'
        }, {
          info: _types.TypeDefInfo.Plain,
          type: 'AccountId'
        }]
      }
    });
  });
  it('returns an actual Struct', () => {
    expect((0, _.getTypeDef)('{"balance":"Balance","account_id":"AccountId","log":"(u64, Signature)"}')).toEqual({
      info: _types.TypeDefInfo.Struct,
      type: '{"balance":"Balance","account_id":"AccountId","log":"(u64,Signature)"}',
      sub: [{
        info: _types.TypeDefInfo.Plain,
        name: 'balance',
        type: 'Balance'
      }, {
        info: _types.TypeDefInfo.Plain,
        name: 'account_id',
        type: 'AccountId'
      }, {
        info: _types.TypeDefInfo.Tuple,
        name: 'log',
        type: '(u64,Signature)',
        sub: [{
          info: _types.TypeDefInfo.Plain,
          type: 'u64'
        }, {
          info: _types.TypeDefInfo.Plain,
          type: 'Signature'
        }]
      }]
    });
  });
});