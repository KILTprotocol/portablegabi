"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = generateQuery;

var _fs = _interopRequireDefault(require("fs"));

var _util = require("@polkadot/util");

var _ = require("../..");

var _static = _interopRequireDefault(require("../../Metadata/static"));

var _util2 = require("../util");

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
// From a storage entry metadata, we return [args, returnType]
function entrySignature(storageEntry, imports) {
  if (storageEntry.type.isPlainType) {
    (0, _util2.setImports)(imports, [storageEntry.type.asType.toString()]);
    return ['', (0, _util2.formatType)(storageEntry.type.asType.toString(), imports)];
  } else if (storageEntry.type.isMap) {
    // Find similar types of the `key` type
    const similarTypes = (0, _util2.getSimilarTypes)(storageEntry.type.asMap.key.toString(), imports);
    (0, _util2.setImports)(imports, [...similarTypes, storageEntry.type.asMap.value.toString()]);
    return ["arg: ".concat(similarTypes.map(type => (0, _util2.formatType)(type, imports)).join(' | ')), (0, _util2.formatType)(storageEntry.type.asMap.value.toString(), imports)];
  } else if (storageEntry.type.isDoubleMap) {
    // Find similartypes of `key1` and `key2` types
    const similarTypes1 = (0, _util2.getSimilarTypes)(storageEntry.type.asDoubleMap.key1.toString(), imports);
    const similarTypes2 = (0, _util2.getSimilarTypes)(storageEntry.type.asDoubleMap.key2.toString(), imports);
    (0, _util2.setImports)(imports, [...similarTypes1, ...similarTypes2, storageEntry.type.asDoubleMap.value.toString()]);
    const key1Types = similarTypes1.map(type => (0, _util2.formatType)(type, imports)).join(' | ');
    const key2Types = similarTypes2.map(type => (0, _util2.formatType)(type, imports)).join(' | ');
    return ["key1: ".concat(key1Types, ", key2: ").concat(key2Types), (0, _util2.formatType)(storageEntry.type.asDoubleMap.value.toString(), imports)];
  }

  throw new Error("entryArgs: Cannot parse args of entry ".concat(storageEntry.name));
} // Generate types for one storage entry in a module


function generateEntry(storageEntry, imports) {
  const [args, returnType] = entrySignature(storageEntry, imports);
  return ["".concat((0, _util.stringLowerFirst)(storageEntry.name.toString()), ": StorageEntryExact<ApiType, (").concat(args, ") => Observable<").concat(returnType, ">> & QueryableStorageEntry<ApiType>;") // `${stringLowerFirst(storageEntry.name.toString())}: QueryableStorageEntry<ApiType>;`
  ];
} // Generate types for one module


function generateModule(modul, imports) {
  if (modul.storage.isNone) {
    return [];
  }

  return [(0, _util2.indent)(4)("".concat((0, _util.stringLowerFirst)(modul.name.toString()), ": {"))].concat((0, _util2.indent)(6)('[index: string]: QueryableStorageEntry<ApiType>;')).concat(modul.storage.unwrap().items.reduce((acc, storageEntry) => {
    return acc.concat(generateEntry(storageEntry, imports).map((0, _util2.indent)(6)));
  }, []).join('\n')).concat([(0, _util2.indent)(4)('};')]);
} // Generate `packages/types-jsonrpc/src/jsonrpc.types.ts` for a particular
// metadata


function generateForMeta(meta) {
  console.log('Writing packages/api/src/query.types.ts'); // Inject all types so that metadata can use them

  require('../../injector');

  const imports = (0, _util2.createImports)(); // Will hold all needed imports

  const body = meta.asLatest.modules.reduce((acc, modul) => {
    const storageEntries = generateModule(modul, imports);
    return acc.concat(storageEntries);
  }, []);
  const header = (0, _util2.createImportCode)(_util2.HEADER, [{
    file: 'rxjs',
    types: ['Observable']
  }, {
    file: '@polkadot/types/codec',
    types: Object.keys(imports.codecTypes).filter(name => name !== 'Tuple')
  }, {
    file: '@polkadot/types',
    types: Object.keys(imports.primitiveTypes)
  }, ...Object.keys(imports.localTypes).map(moduleName => ({
    file: "@polkadot/types/interfaces/".concat(moduleName),
    types: Object.keys(imports.localTypes[moduleName])
  })), {
    file: '@polkadot/types/types',
    types: Object.keys(imports.typesTypes)
  }]);
  const interfaceStart = ["declare module './types' {", (0, _util2.indent)(2)('export interface QueryableStorageExact<ApiType> {\n')].join('\n');
  const interfaceEnd = "\n".concat((0, _util2.indent)(2)('}'), "\n}");

  _fs.default.writeFileSync('packages/api/src/query.types.ts', header.concat(interfaceStart).concat(body.join('\n')).concat(interfaceEnd).concat(_util2.FOOTER), {
    flag: 'w'
  });
} // Call `generateForMeta()` with current static metadata


function generateQuery() {
  return generateForMeta(new _.Metadata(_static.default));
}