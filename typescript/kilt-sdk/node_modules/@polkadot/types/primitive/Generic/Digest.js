"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DigestItem = void 0;

var _util = require("@polkadot/util");

var _Enum = _interopRequireDefault(require("../../codec/Enum"));

var _Struct = _interopRequireDefault(require("../../codec/Struct"));

var _Vec = _interopRequireDefault(require("../../codec/Vec"));

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.

/**
 * @name DigestItem
 * @description
 * A [[Enum]] the specifies the specific item in the logs of a [[Digest]]
 */
class DigestItem extends _Enum.default {
  constructor(value) {
    super({
      Other: 'Bytes',
      // 0
      AuthoritiesChange: 'Vec<AuthorityId>',
      // 1
      ChangesTrieRoot: 'Hash',
      // 2
      SealV0: 'SealV0',
      // 3
      Consensus: 'Consensus',
      // 4
      Seal: 'Seal',
      // 5
      PreRuntime: 'PreRuntime' // 6

    }, value);
  }
  /**
   * @description Returns the item as a [[Vec<AuthorityId>]]
   */


  get asAuthoritiesChange() {
    (0, _util.assert)(this.isAuthoritiesChange, "Cannot convert '".concat(this.type, "' via asAuthoritiesChange"));
    return this.value;
  }
  /**
   * @description Returns the item as a [[ChangesTrieRoot]]
   */


  get asChangesTrieRoot() {
    (0, _util.assert)(this.isChangesTrieRoot, "Cannot convert '".concat(this.type, "' via asChangesTrieRoot"));
    return this.value;
  }
  /**
   * @desciption Retuns the item as a [[Consensus]]
   */


  get asConsensus() {
    (0, _util.assert)(this.isConsensus, "Cannot convert '".concat(this.type, "' via asConsensus"));
    return this.value;
  }
  /**
   * @description Returns the item as a [[Bytes]]
   */


  get asOther() {
    (0, _util.assert)(this.isOther, "Cannot convert '".concat(this.type, "' via asOther"));
    return this.value;
  }
  /**
   * @description Returns the item as a [[PreRuntime]]
   */


  get asPreRuntime() {
    (0, _util.assert)(this.isPreRuntime, "Cannot convert '".concat(this.type, "' via asPreRuntime"));
    return this.value;
  }
  /**
   * @description Returns the item as a [[Seal]]
   */


  get asSeal() {
    (0, _util.assert)(this.isSeal, "Cannot convert '".concat(this.type, "' via asSeal"));
    return this.value;
  }
  /**
   * @description Returns the item as a [[SealV0]]
   */


  get asSealV0() {
    (0, _util.assert)(this.isSealV0, "Cannot convert '".concat(this.type, "' via asSealV0"));
    return this.value;
  }
  /**
   * @description Returns true on [[AuthoritiesChange]]
   */


  get isAuthoritiesChange() {
    return this.type === 'AuthoritiesChange';
  }
  /**
   * @description Returns true on [[ChangesTrieRoot]]
   */


  get isChangesTrieRoot() {
    return this.type === 'ChangesTrieRoot';
  }
  /**
   * @description Returns true on [[Consensus]]
   */


  get isConsensus() {
    return this.type === 'Consensus';
  }
  /**
   * @description Returns true on [[Other]]
   */


  get isOther() {
    return this.type === 'Other';
  }
  /**
   * @description Returns true on [[PreRuntime]]
   */


  get isPreRuntime() {
    return this.type === 'PreRuntime';
  }
  /**
   * @description Returns true on [[Seal]]
   */


  get isSeal() {
    return this.type === 'Seal';
  }
  /**
   * @description Returns true on [[SealV0]]
   */


  get isSealV0() {
    return this.type === 'SealV0';
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers. For logs, we overrides to produce the hex version (sligning with substrate gives in actual JSON responses)
   */


  toJSON() {
    return this.toHex();
  }
  /**
   * @description Returns the type of engine
   */


  get type() {
    return super.type;
  }

}
/**
 * @name Digest
 * @description
 * A [[Header]] Digest
 */


exports.DigestItem = DigestItem;

class Digest extends _Struct.default {
  constructor(value) {
    super({
      logs: _Vec.default.with(DigestItem)
    }, value);
  }
  /**
   * @description The [[DigestItem]] logs
   */


  get logs() {
    return this.get('logs');
  }
  /**
   * @description The [[DigestItem]] logs, filtered, filter items included. This is useful for derive functionality where only a certain type of log is to be returned.
   */


  logsWith() {
    for (var _len = arguments.length, include = new Array(_len), _key = 0; _key < _len; _key++) {
      include[_key] = arguments[_key];
    }

    return this.logs.filter((_ref) => {
      let {
        type
      } = _ref;
      return include.includes(type);
    });
  }
  /**
   * @description The [[DigestItem]] logs, filtered, filter items exluded. This is useful for stripping headers for eg. WASM runtime execution.
   */


  logsWithout() {
    for (var _len2 = arguments.length, exclude = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      exclude[_key2] = arguments[_key2];
    }

    return this.logs.filter((_ref2) => {
      let {
        type
      } = _ref2;
      return !exclude.includes(type);
    });
  }

}

exports.default = Digest;